## 1. 게임 개요

- **타이틀 :** Castle Guardian + VR  
- **장르 :** 디펜스 슈팅 + VR
- **플랫폼 :** PC + Meta Quest 3 (VR)
- **엔진 :** Unity + Meta Quest SDK  
- **플레이 방식 :** 전장을 조망하며, 적의 경로를 내려다보면서 활과 방어 시스템을 사용해 침략을 막는 디펜스 게임.
- **저장소 주소 :** https://github.com/Femur-0607/Castle-Guardian-VR

### 1.1. 추진 배경

- 나는 평소 **디펜스 게임을 좋아하고**, VR에서 경험했던 **활쏘기 조작이 신선**해서 이를 결합한 **하이브리드 디펜스 게임**을 구상.

- VR 특유의 **1인칭 몰입감**과 **전략적인 디펜스** 요소를 결합해, 기존 디펜스와 차별화된 재미를 제공하고자 함.

- 최근 VR 시장이 빠르게 성장하며, 독립형 VR 기기의 성능도 향상되고 있음. 이에 따라 몰입감 있는 게임 체험을 원하는 유저가 늘어나고 있으며, ‘Meta Quest 3’, ‘Apple Vision Pro’ 등 다양한 하드웨어 생태계가 등장함. 이 프로젝트를 통해, VR 환경만의 게임 디자인·UX 설계 노하우를 직접 체득하자 함.

- **PC 환경**에서 기본 시스템을 먼저 구현(적 AI, 웨이브, 상점, 타워 배치 등) 후 **VR 포팅**을 통해 **최적화**와 **VR UX**를 다듬을 예정

---

## 2. 시놉시스 및 스토리 라인
### 2.1. 시놉시스

**전설의 사령관, 반신의 부활**

고대 왕국 **아르덴**의 위대한 전사였던 그는, 전장에서 목숨을 잃었지만 신들의 은총을 받아 **반신**으로 다시 태어났다. 
한때 뛰어난 사령관으로서 수많은 전투를 승리로 이끈 그의 영혼은, 이제 미완의 사명과 왕국에 대한 뜨거운 애정으로 다시 불타오른다.

어둠이 드리운 아르덴의 땅에 외세의 침략이 몰아치자, 그의 눈에는 오직 하나의 결의만이 비친다. 잃어버린 과거의 영광과 무게를 짊어진 채, 그는 마지막까지 왕국을 지키기 위한 불멸의 결단을 내린다.

신의 분노와 인간의 의지가 하나 되어 타오르는 이 전설은, 이제 새로운 시대의 서막을 알린다. 아르덴의 밤을 밝힐 희망, 그것은 바로 그가 남긴 불멸의 유산이다.

### 2.2. 웨이브별 다이얼로그 시스템 (스토리라인 예시)

| 웨이브 | 이벤트               | NPC 대사( 신들의 목소리 )                                  |
| --- | ----------------- | -------------------------------------------------- |
| 1   | 튜토리얼              | "반신이여, 왕국을 지킬 때가 왔다! 활을 들어 적을 막아라!"                |
| 3   | 첫 번째 보스 출현 (중간보스) | "이방인들의 우두머리가 나타났다! 그들의 맹공을 막아야 한다!"                |
| 5   | 배후의 배신자 암시        | "이 공격에는 무언가 더 깊은 음모가 있다… 배후에 또 다른 세력이 있는 것이 틀림없다!" |
| 7   | 유령 적 등장           | "어둠의 마법이 발동했다! 유령 병사들이 전장을 가로지르고 있다!"              |
| 10  | 최종 보스 등장          | "마침내 적들의 최강자가 모습을 드러냈다… 이 전투가 마지막이다!"              |

---
## 3. 게임 목표 및 승패 조건

1. **목표:** 성문이 부서지지 않도록 적의 공세를 막아내는 것.
2. **승리 조건:** 특정 웨이브(예: 10웨이브)를 방어하면 게임 클리어.
3. **패배 조건:** 성문의 체력이 0이 되면 게임 오버.

---

## 4. 핵심 게임 시스템(기능)
### 4.1. 맵 구성

- [[기획서 참고자료#게임 전체적인 배경 및 환경 참고 이미지]]
1. **한정된 전장 :** 3면이 산으로 둘러싸여 있고, 1면에서 적이 스폰.
2. **성문 :** 적이 성문까지 도달하면 체력이 감소.
3. **타워 설치 공간 :** 적 경로 주변 특정 지점에 방어 타워 배치 가능.
4. **플레이어 위치 및 시야각 :** "플레이어는전략적 3D 탑뷰 + 1인칭 활쏘기"
	- 일정한 높이에서 적의 경로를 한눈에 내려다볼 수 있도록 설계
	- 방어 구조물 배치나 전장의 상황이 한눈에 들어옴
	- **1인칭**으로 공격 및 조작을 해야함.

### 4.2. 전투 시스템

- [[기획서 참고자료#화살 참고 이미지]]
1. **기본 무기(화살) :**
	- VR을 고려해 **컨트롤러 트리거** or **마우스 드래그**로 활을 당겨 발사.
2. **특수 화살:** 폭발 화살, 둔화 화살, 불꽃 화살 등 전략적인 요소 추가 가능.
	- 상점에서 해금 가능하며 컨트롤러의 키입력에 따라서 화살 변화 가능
3. **화살 수급:** 제한된 화살을 상점을 통해 구매하여 보충해야 함.
	- 음성 인식 AI를 이용해서 "화살 보충!", "화살" 이라고 사용자가 말하면 화살이 보충되게끔 하는 가능성도 고려
4. **화살 조준 보조:** 포물선 가이드라인을 통해 화살 도착지를 미리 확인할 수 있도록 지원.

### 4.3. 적 AI 시스템

- [[기획서 참고자료#게임의 로직 및 진행 웨이브 참고 이미지]]
1. **일반 병사:** 성문을 향해 돌격하는 기본 적, 성문 도착 시 성문을 공격.
2. **궁수형 적:** 성문을 원거리에서 공격.
3. **정찰병:** 빠른 속도로 이동해서 성문을 공격.
4. **탱커형 적(중간 보스):** 체력이 높으며 공격속도는 느리지만 대미지가 강함,
5. **유령형 적:** **ML-Agents** 활용, 지형을 무시하며 플레이어를 추격. 닿으면 일정 시간 스턴 상태로 만듦.
6. **최종 보스** : 동료 궁병이나 포탑의 데미지는 덜받고 플레이어의 활 실력에따라 격파가능 하게끔( 부위 파괴 시스템같은게 있으면 좋을듯) (그러면 성벽쪽으로 시야가 바뀌어서 보스의 모습을 전부 담아야함), 쫄몹을 소환해서 주변 동료 및 타워는 쫄몹을 공격
	- [[기획서 참고자료#최종보스 참고 이미지]]
### 4.4. 네비게이션 시스템

1. **네비메쉬(NavMesh) 활용:** 적들의 이동 경로 제한 및 성문 돌격 유도.
2. **특수 유닛 예외 처리:** 유령형 적은 네비메쉬를 무시하고 직접 이동.
3. [[기획서 참고자료#^d7u14u]]

### 4.5. 방어 시스템 및 UI

- [[기획서 참고자료#UI 참고 이미지]]
4. **NPC 동료 궁수:** 상점에서 구매 → 성벽 위나 지정 위치에서 자동 공격.
	- 화살쏘는 모션만 나오고 실제로는 쏘지않음
	- 가장 가까운 적을 담아서 공격모션이 나오고 데미지 들어감.
5. **방어 타워 :** 상점에서 구매 → 지정 위치에서 자동 공격.
	- 상점에서 구매시 UI창이 비활성화, 직선 레이가나와서 위치 선정 가능
	- 타워 업그레이드 기능 : 데미지 업, 상태이상(스턴, 슬로우)를 가하게끔 업그레이드 기능
6. **재화 획득:** 적 처치 시 획득. 적의 종류에 따라 차등 지급.
7. **상점 시스템:**
    - 화살 보충
    - 특수 화살 구매
    - NPC 동료 궁수 구매
    - 방어 타워 건설
    - 성문 수리
    - 플레이어 기본 스테이트 상승 ( 공격력, 재장전 속도 등등)
8. **웨이브 종료 시 상점 활성화:** 웨이브 종료 시 일정시간 활성화, 아이템 및 업그레이드 구매.

---

## 5. 기술적 구현 세부 계획
### 5.1. 컨트롤러 및 플레이어 인터페이스

- **Unity Input System** 을 활용하여 PC 및 VR 컨트롤러 조작을 동기화
- 마우스의 회전과 VR의 움직임을 추적하는 카메라(시야)이동
- **XR Interaction System** 활용하여 기본 조작 구현
    - `XR Ray Interactor` 및 `XR Teleportation Provider` 활용 (텔레포트 이동)
    - 트리거와 동작을 이용한 화살 발사
- **UI 및 상호작용**
    - PC는 마우스 클릭으로 상호작용, VR에서는 레이와 추가 키입력으로 상호작용
    - `Canvas UI` + `XR UI Interaction`을 사용하여 VR 친화적인 UI 적용

### 5.2. 전투 시스템
#### 5.2.1. 화살 발사 및 물리 구현

- ##### PC(마우스) 이벤트 기반 발사 로직
9. **OnMouseDown**
    - 활 준비 자세 (활 오브젝트 활성화 또는 화살 소환)
    - 활 장전 애니메이션 시작
10. **OnMouseDrag**
    - 마우스를 드래그하여 **활을 당기는 거리** 계산 (예: `Vector2.Distance()`)
    - **당김 정도**에 따라 **카메라 진동** 및 **화살 흔들림** 효과를 점진적으로 증가
    - 일정 임계점(최대로 당김)에 도달 시, **활 장력** 최대로 설정
11. **OnMouseUp**
    - 버튼을 놓는 순간 **화살 발사**
    - `Rigidbody.AddForce()` 혹은 `Physics.Raycast()` 다른 방식으로 발사체 물리 적용
    - 발사 후 활 복원(장전 상태 해제), 애니메이션 리셋

- ##### VR(컨트롤러) 이벤트 기반 발사 로직
12. **Trigger Down**
    - 컨트롤러 트리거 버튼을 당기면 **활이 준비**됨
    - VR 환경에서 시각적으로 활-화살이 손에 붙은 상태
13. **Trigger Hold**
    - 트리거를 누르고 있는 동안 활 당기는 모션 진행
    - **컨트롤러 진동**(Haptic)이나 **시야 흔들림**으로 장력 표현
    - **최대로 당긴 상태**에서는 활이 미세하게 흔들려 조준 난이도 증가
14. **Trigger Up**
    - 트리거 버튼을 놓는 순간 **화살 발사**
    - `XR Interaction Toolkit` 또는 `Physics` 로직으로 투사체 발사
    - 화살이 날아간 후, 활 장전 상태 초기화

| **구분**       | **입력 이벤트**    | **설명**         |
| ------------ | ------------- | -------------- |
| **PC(마우스)**  | OnMouseDown   | 활 준비           |
|              | OnMouseDrag   | 활 당기기 (발사력 조절) |
|              | OnMouseUp     | 화살 발사          |
| **VR(컨트롤러)** | OnTriggerDown | 화살 준비          |
|              | OnTriggerHold | 활 당기기 (발사력 조절) |
|              | OnTriggerUp   | 화살 발사          |

> **참고 자료**
> - [[기획서 참고자료#^l93ksp]], [[기획서 참고자료#^g32vpj]]
> - 각 이벤트 단계에서 **LineRenderer**로 포물선 궤적 표시 가능
> - 탄도학(Projectile) 계산 시 `Time.deltaTime` 또는 `FixedUpdate()`를 적절히 활용
> - `Collider` 및 `OnTriggerEnter()`를 활용한 적과의 충돌 판정
> - 스팀VR에서는 기본적인 활쏘는 예제가 있어서 참고하기

#### 5.2.2. 화살 클래스
### **✅ 기본적인 구조**
- `Arrow` (기본 화살 클래스) → 모든 화살의 공통 기능을 정의
- `ExplosiveArrow` (폭발 화살) → 범위 피해를 주는 폭발 효과 (`Physics.OverlapSphere` 활용)
- `SlowArrow` (둔화 화살) → 적의 이동 속도 감소 (`NavMeshAgent.speed` 조정)
- `FireArrow` (불 화살, 선택 가능) → DOT(Damage Over Time)(도트데미지) 적용 가능(코루틴을 적용)
- 모든 화살의 스탯(데미지, 속도 등)은 `ScriptableObject`로 관리하며, 상점에서 업그레이드 가능

📌 **클래스 간 상속 관계**
```
[Weapon] (추상 클래스 - 확장 가능)
    ├── [Bow] (활, 고정)
    
[Arrow] (추상 클래스 - 모든 화살의 공통 기능)
    ├── [NormalArrow] (기본 화살)
    ├── [ExplosiveArrow] (폭발 화살)
    ├── [SlowArrow] (둔화 화살)
    ├── [FireArrow] (불 화살)

[ArrowData] (ScriptableObject - 화살 정보 관리)
```

| **클래스**          | **설명**                             |
| ---------------- | ---------------------------------- |
| `Arrow`          | 기본 화살 클래스 (공통 기능)                  |
| `NormalArrow`    | 일반 화살 (추가 기능 없음)                   |
| `ExplosiveArrow` | 범위 공격 (Physics.OverlapSphere)      |
| `SlowArrow`      | 적 이동 속도 감소 (NavMeshAgent.speed 조정) |
| `Bow`            | 화살을 교체하며 발사                        |
### **🔥 화살 정보(`ScriptableObject`) 관리**
각 화살의 **공격력, 재사용 속도, 특수 효과(폭발 반경, 둔화 지속시간 등) 등을 `ScriptableObject`로 저장**하여 관리.

|**속성**|**설명**|
|---|---|
|`damage`|기본 공격력|
|`reloadTime`|재사용 속도(연사 속도)|
|`specialEffectDuration`|특수 효과 지속 시간 (예: 둔화, 불 데미지)|
|`upgradeCost`|업그레이드 비용|
|`level`|업그레이드 레벨|

#### 5.2.3. 특수 화살 구현

- **폭발(`ExplosiveArrow`):** 범위 공격(``Physics.OverlapSphere`)
- **둔화(`SlowArrow`):** 적의 `NavMeshAgent.speed` 저하
- **불 화살(`FireArrow`):** DOT(지속 데미지) 적용

### 5.3. 적 AI 및 웨이브 시스템

#### 5.3.1. 기본 적 AI

- `NavMeshAgent.SetDestination()`을 사용한 경로 탐색
- **FSM (Finite State Machine)** 을 활용하여 적 행동 패턴 구현
    - 이동 (`Patrol`)
	    - 목적지를 성문으로 설정
	- 적 AI(FSM)에서 NavMeshAgent의 **`remainingDistance`** 또는 `pathPending`을 확인하여, “남은 거리가 일정 이하가 되면 공격 상태로 전환”하도록 처리할 수 있습니다.
    - 공격 (`Attack`)
	    - 성문에 도달시 ()
	    - 상속 받을 몬스터 유형마다 개별 작성(공격력 공격속도 등)
	    - 몬스터의 데이터는 `Scriptable Object` 로 관리

📌 **클래스 간 상속 관계**
```
[Enemy] (추상 클래스)  
├─ [SoldierEnemy] (일반 병사)
├─ [ArcherEnemy] (궁수형 적)
├─ [scoutEnemy] (정찰병)  
├─ [TankEnemy] (탱커형 적)  
├─ [GhostEnemy] (ML-Agents 사용, 네비메쉬 미사용)
[Boss] (개별 클래스)
```
#### 5.3.2. 적 AI 확장
- **유령형 적 :** `ML-Agents`를 활용한 경로 무시 이동
- **최종보스 :** 스폰 기능도 겸하고 있어서 일정시간마다 쫄몹 소환

#### 5.3.3. 웨이브 시스템

- `SpawnManager.cs`를 활용하여 일정 시간마다 적 생성
- `WaveManager.cs`에서 웨이브 진행 및 난이도 스케일링 조정
- GameFlowManager(혹은 StageManager)
	- - **역할:**
    - 웨이브 시작/종료 이벤트
    - 보스 등장 타이밍, 연출 관리
    - 게임이 일시정지/종료/클리어 되었는지 일괄 체크
    - 씬 전환(메인 메뉴 ↔ 인게임) 등도 중앙에서 관리
	- **장점:**
	    - `WaveManager`, `SpawnManager`, `ShopManager` 같은 스크립트가 모두 **한 지점**의 신호를 받고 동작을 개시하므로, **이벤트 의존 관계**가 명확해집니다.
	- **예시:**
	    - 게임 시작: `OnGameStart` → 적 웨이브 시작
	    - 웨이브 클리어: `OnWaveClear` → 상점 UI 호출, 보스 소환 여부 체크
	    - 최종 보스 클리어: `OnGameClear` → 엔딩 연출, 결과 화면 표시

### 5.4. 방어 시스템 및 타워 배치
#### 5.4.1. 방어 타워

- `Instantiate()`를 활용한 타워 배치 시스템
- `NavMeshObstacle`을 사용하여 AI 경로 방해 가능

#### 5.4.2. 방어 타워 유형

- **Tower (추상 클래스)**
    - **공통 필드**: `level`, `attackRange`, `attackCooldown`, `lastAttackTime` 등
    - **공통 메서드**
        - `DetectEnemy()` : 범위(`attackRange`) 내의 적을 탐색
        - `Attack(Enemy target)` : 추상 메서드 → 하위 클래스가 구체 구현
        - `UpgradeLevel()` : 업그레이드 시 공통적으로 레벨, 공격력, 사거리 등의 수치 상승
- **ArcherTower**
    - 단일 타겟(Nearest Enemy) 공격
    - `Attack()` 시 **일반 화살** 발사
    - 화살 오브젝트를 **Instantiate** 하거나 풀링 시스템을 통해 생성
    - (추가 가능) 연사 속도 빠름, 단일 대상에 강한 특성
- **CannonTower**
    - 범위 폭발(예: `Physics.OverlapSphere`)
    - `explosionRadius` 필드 추가 → `Attack()` 시 해당 반경 내 적에게 피해
    - 연사 속도 느리지만 광역 공격에 유리
- **Trap**
    - 원거리 투사체가 아니라, 일정 지연 후 발동하는 **지상 트랩**
    - `triggerDelay`로 대기 시간 설정 → **OnTriggerEnter** 등으로 범위 내 적을 슬로우 or 스턴
    - 이동식이 아닌 **설치형**이라면, AI 자동 공격 대신 “적이 밟으면 발동” 같은 로직이 필요할 수도 있음.
        - 방해물 오브젝트를 경로에 쏴서 에너미랑 충돌하면 오버랩 스케어등으로 범위 상태이상 구현

### 5.5. 상점 및 경제 시스템 & UI
#### 5.5.1. 재화 시스템

- 적 처치 시 `GoldManager`를 활용하여 재화 획득 (`UI 업데이트`)
- 특정 적 유형에 따라 차등 지급

#### 5.5.2. 상점 구현

- `Canvas UI` 및 `VR UI Interaction`을 통해 메뉴 표시
- `ShopManager.cs`에서 아이템 구매 처리 (`PlayerPrefs` 또는 `ScriptableObject` 활용)
- 웨이브 종료 후 상점 자동 활성화
- 업그레이드 시 `ArrowData` 값이 변경됨 (`damage`, `reloadTime` 등 증가)

📌 **업그레이드 예시**
```
[ 🔥 화살 상점 ] 
----------------------- 
▶ 일반 화살 (공격력 +5) [업그레이드: 100 Gold] 
▶ 폭발 화살 (폭발 반경 +2m) [업그레이드: 150 Gold] 
▶ 둔화 화살 (둔화 지속시간 +2초) [업그레이드: 120 Gold]
```

#### 5.5.3. UI 피드백
- 상점에서 돈이 부족할경우, 알림이 필요한경우  `CameraShaker` 를 이용해서 진동 피드백
	- VR의 경우 컨트롤러 햅틱진동을 이용해서 피드백주기
### 5.6. 환경 및 최적화

- 터레인 지형 생성 (`TerrainTools` 활용)
- VR 최적화 (`Oculus Performance HUD` 활용)
- 오디오 최적화 (`Oculus Spatializer` 사용하여 3D 사운드 적용)
#### 5.6.1. 오브젝트 풀링(Object Pooling) 적용:

-  화살, 적, 방어 타워 등 빈번히 생성/삭제되는 오브젝트를 풀링 시스템으로 관리 
- 가비지 컬렉션(GC) 최소화하여 VR 성능 최적화
#### 5.6.2. Light Probe 활용하여 이동 오브젝트(적, 플레이어, 화살 등)에 자연스러운 조명 적용 

- 실시간 조명을 최소화하고, Light Probe Grid를 활용하여 VR 성능 최적화
#### 5.6.1. LOD(Level of Detail) 시스템 적용하여 VR 성능 최적화: 

- 먼 거리의 적, 방어 타워, 환경 오브젝트는 저해상도 모델로 전환 
- VR 최적화 셰이더(Oculus Shader) 적용하여 성능 유지
- UI는 Unlit 셰이더를 사용하여 렌더링 부하 최소화
- Meta Quest 3의 **Foveated Rendering** 기능 활용: 
	- 사용자의 시선 중심부를 고해상도로 렌더링하고 주변부 해상도를 자동 조정 - VR 렌더링 성능 최적화 및 프레임 유지
### 5.7. 클래스·인터페이스 설계

#### 5.7.1. 추상 클래스 예시

- **`Enemy`**(이동·공격·피해 공통) → `SoldierEnemy`, `ArcherEnemy` 등
- **`Arrow`**(발사·충돌 공통) → `ExplosiveArrow`, `SlowArrow` 등
- **`Tower`**(업그레이드·공격 공통) → `ArcherTower`, `CannonTower` 등

#### 5.7.2. 인터페이스 예시

| 인터페이스           | 대상                  | 설명                               |
| --------------- | ------------------- | -------------------------------- |
| `IUpgradeable`  | 타워, 특수 화살, NPC 동료 등 | 업그레이드 가능 (`UpgradeLevel()`)      |
| `IDamageable`   | 적, 플레이어, 타워         | 피격 처리 (`TakeDamage()`)           |
| `IInteractable` | 상점, 아이템, 타워 배치 오브젝트 | 플레이어와 상호작용 (`Interact()`)        |
| `IProjectile`   | 화살, 대포알 등 투사체       | 발사(`Launch()`), 충돌(`OnHit()`) 구현 |

#### A. `IUpgradeable` (업그레이드 가능한 객체)

- **설명:** 방어 타워, 특수 화살, NPC 동료 궁수 등에 적용하며, `UpgradeLevel()`을 구현하면 업그레이드 기능을 활성화할 수 있다.
- **적용 대상:** `Tower`, `ExplosiveArrow`, `NPCArcher`
- **설명:** 방어 타워, 특수 화살, NPC 동료 궁수 등에 적용하며, `UpgradeLevel()`을 구현하면 업그레이드 기능을 활성화할 수 있다.
- **적용 대상:** `Tower`, `ExplosiveArrow`, `NPCArcher`
✔ **레벨 업그레이드 (`UpgradeLevel()`)**  
✔ **업그레이드 비용 확인 (`GetUpgradeCost()`)**

#### B. `IDamageable` (피해를 받을 수 있는 객체)

- **설명:** 적, 플레이어, 방어 타워 등 공격을 받을 수 있는 모든 대상에 적용하여, 피해를 입었을 때 `TakeDamage()`가 호출될 수 있도록 한다.
- **적용 대상:** `Enemy`, `Player`, `Tower`
✔ **피해 적용 (`TakeDamage()`)**  
✔ **체력 확인 (`IsAlive()`)**

#### C. `IInteractable` (플레이어가 상호작용할 수 있는 오브젝트)

- **설명:** 플레이어가 직접 조작할 수 있는 상점, 아이템, 방어 타워 배치 오브젝트에 적용하여 상호작용이 가능하도록 한다.
- **적용 대상:** `ShopItem`, `TowerPlacement`, `CollectibleItem`

✔ **플레이어와 상호작용 (`Interact()`)**

#### D. `IProjectile` (투사체 관련 인터페이스)

- **설명:** 화살, 대포알, 마법탄 등 모든 투사체가 구현해야 할 발사 및 충돌 처리를 정의한다.
- **적용 대상:** `Arrow`, `CannonBall`, `MagicProjectile`

✔ **발사 (`Launch()`)**  
✔ **충돌 효과 (`OnHit()`)**

📌 **인터페이스 적용 예시**
```
IUpgradeable  → Tower, ExplosiveArrow, NPCArcher 
IDamageable   → Enemy, Player, Tower 
IInteractable → ShopItem, TowerPlacement 
IProjectile   → Arrow, CannonBall
```

### 5.8. 사운드

#### 5.8.1. AudioManager

**`AudioManager`**:

- BGM/SE/Voice 등을 `Dictionary<string, AudioClip>` 형태로 관리
- 3D 사운드는 각 적이나 타워에 `AudioSource`를 붙이되, **전역 볼륨**은 `AudioManager`에서 제어

- **역할:**
    - 배경음(BGM), 효과음(SFX), 보이스(Voice) 등을 **중앙에서 통합 관리**
    - 사운드 볼륨 옵션 저장/로드
- **장점:**
    - VR에서는 입체음향(Spatial Audio)이 중요하므로, `Oculus Spatializer`나 `Meta XR Audio SDK`(​)를 연동할 때도 **하나의 매니저**가 전체 소리를 조절하면 편리합니다.
    - 옵션 메뉴에서 음소거나 볼륨 변경 시 바로 반영 가능

### 5.9. 데이터 관리 & UI
#### 5.9.1. Save/Load (데이터 영속화)

**`SaveManager`** (혹은 `DataManager`):

- 플레이어 진척도(웨이브, 골드, 업그레이드 상태 등) 저장/로드
- Unity 내장 `JsonUtility`, `PlayerPrefs`, `ScriptableObject` 등 방식을 선택

- **역할:**
    - 플레이어가 진행한 웨이브, 업그레이드 현황, 화살 종류 언락 상태 등을 저장
    - VR에서도 로컬 저장(안드로이드폰의 내부 저장소)이나 **클라우드 연동(AWS, Firebase 등)** 을 할 수 있음
- **장점:**
    - 시나리오나 보스 클리어 단위로 **오프라인 세이브**를 지원할 경우, 유저가 VR 헤드셋 배터리가 소모되어 게임을 꺼도 **다음 플레이 때 이어서** 진행할 수 있음

#### 5.9.2. UI Manager & 아키텍처 (MVP/MVVM/UniRx 등)

- **`UIManager`**: 상점, 옵션, 일시정지 메뉴, 결과 화면 등 통합 관리
- **MVVM/MVP** 패턴을 부분 적용해, View(게임오브젝트)와 Model(데이터) 분리
    - **UniRx** 활용 시, `ReactiveProperty`를 써서 “골드 값” 등이 바뀌면 UI 자동 갱신
    - 규모가 작은 시스템부터 부분 적용 권장

#### 5.9.3. 일시정지(Pause) & 옵션 메뉴

**목표:**
- 게임 도중에도 상점·옵션 메뉴 등을 원활히 이용하기 위해, **일시정지 기능**을 구현한다.
- VR 환경에서 “일부 시스템은 멈추되, UI나 일부 연출은 계속 동작”하도록 세밀하게 제어한다.

##### A) 기본 구현: 싱글톤 매니저 + bool isPaused + 이벤트(Observer) 패턴

15. **GameManager 싱글톤**
    - 전역적으로 접근 가능한 `GameManager.Instance` 내부에 `bool isPaused` 변수를 둔다.
    - `SetPause(bool pause)` 메서드를 통해 일시정지 On/Off를 제어한다.
16. **Observer(이벤트) 패턴**
    - `GameManager`에서 “`onPauseStateChanged(bool isPaused)`” 같은 이벤트를 발행한다.
    - 적 AI, 플레이어 제어, UI, 사운드 등 “멈춰야 할” 스크립트들이 이 이벤트를 **구독**해 놓는다.
    - 일시정지 되면 해당 스크립트들의 **Update** 로직을 중단하거나, NavMeshAgent·Animator를 정지시키는 등 필요한 처리를 한다.
17. **Update 분기 처리**
    - 간단히 `if (GameManager.Instance.isPaused) return;` 조건을 둬서 로직을 멈출 수도 있고,
    - 이벤트 콜백에서 “`AI.Stop(); Animator.speed = 0;`” 식으로 처리해도 된다.
18. **장점**
    - `Time.timeScale = 0` 방식과 달리, **UI나 특정 연출을 계속** 구동할 수 있음.
    - 각 시스템별로 “멈출지/계속할지”를 세밀히 제어 가능.
    - 스크립트 규모가 커지더라도, “Pause 상태가 바뀔 때 이벤트를 한 번만 수신”하여 필요한 로직만 실행하면 되므로 깔끔하다.

##### B) 추가 목표(심화): UniRx 또는 r3 등 Reactive 라이브러리 도입

19. **ReactiveProperty**
    - `BoolReactiveProperty isPaused;` 를 사용하면 `isPaused.Value = true;` 시 자동으로 구독자에게 변경 사항을 전달한다.
    - 기존 C# 이벤트를 수작업으로 등록·해제할 필요가 줄어들고, 코드가 간결해진다.
20. **LINQ to Events**
    - `.Where()`, `.TakeUntilDestroy()`, `.DistinctUntilChanged()` 같은 Reactive 연산자를 활용해, 구독 흐름을 유연하게 제어할 수 있다.
21. **장점 및 유의사항**
    - 대규모 이벤트 흐름을 Reactive로 일원화할 수 있어 **개발 생산성** 향상.
    - 다만 **초반 러닝 커브**가 존재하며, 구독 해지(`Dispose`) 처리 등 메모리 관리에 주의해야 한다.
##### C) “State Manager” 방식과의 연계

- **State Manager** 또는 **FSM**을 쓰는 구조에서도, “PAUSE 상태”를 하나의 스테이트로 둔 뒤
    - 적 AI·웨이브 스크립트 등은 “PAUSE가 아닐 때만 Update”를 실행하도록 할 수 있다.
- 이때도 내부적으로는 “**`isPaused` bool + 이벤트**”를 활용하므로 큰 충돌 없이 설계 가능.

##### 결론 및 적용 계획

- **우선** `GameManager` 싱글톤에 `bool isPaused`, `onPauseStateChanged` 이벤트를 두어 **일시정지**를 구현한다.
- 시간이 허용되거나 프로젝트가 커지면, **UniRx(r3 포함)** 등 **Reactive** 라이브러리를 도입하여 구독·해제를 자동화하고 **코드량을 줄이는 방식**으로 확장한다.
- 옵션 메뉴에서는 “사운드 볼륨 / 그래픽 설정” 등을 다루며, 일시정지 중에도 **UI**를 활성화하고, 적 AI나 물리만 멈출 수 있도록 설계한다.
## 6. 추가 고려 사항

- VR UX 개선 (상점 인터페이스, 화살 조준 보조 등)
- 멀티플레이 요소 추가 가능성 검토 (보류, 포톤에서 리얼타임이나 퓨전 사용?)
	- [포톤](https://www.photonengine.com/ko-kr)
- AI 음성 인식 (플레이어가 “타워 설치!” 외치면 상호작용 등)
- **Localization(다국어)**, **TTS/보이스 연출**
- - [[기획서 참고자료#^mx6inn]]
	- 다이얼로그 시스템은 무료 에셋 사용( 사용법은 확실하게)

---
## 관련 자료

- [[기획서 참고자료]]
- [[VR게임 단위 기간 목표]]
- [[Castle Guardian 흐름도.png]]